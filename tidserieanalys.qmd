---
title: "Marking guide assignment GLM"
author: "Jacob rak, William Lindquist. Aram Vardanian"
date: "`r Sys.Date()`"
output:
  pdf_document:
    toc: true
  html_document:
    toc: true
    toc_float: true
editor_options:
  markdown:
    wrap: 72
---

# Step 1 

Datasetet kommer från
[https://www.kaggle.com/datasets/vijayvvenkitesh/microsoft-stock-time-series-analysis](#0).
Datasetet är en tidserieanalys av Microsoft aktiken MSTF som är listad
på den amerikanska markanden. Uppgifterna hämtades från Google Sheets
med hjälp av "GOOGLEFINANCE".

```{r}
dataframe = read.csv("Microsoft_Stock.csv")
```

## Varibler

Datasetet har över 1511 observationer med 6 olika varibler.

-   Date(från 04/01/2015 till 04/01/2021)

-   Open(Pris vid öppning)

-   high(högst värdet för den dagen)

-   Low(lägsta priset)

-   Close(stängnings priset)

-   Volume(volymen av sålda aktiker)

## Periodictet

Periodiciteten av dataframen är dagligen.

## Val av varibler

För en robust och nyancerad analys kommer det framförallt används av
Open, high och low som hjälpvariblen och Close som huvudvarible.
Motiveringen följer, det finns en naturlig koppling mellan dessa för att
kunna förutspå aktien closing price från ett mänskligt perpektiv.

## Grafer 

```{r}
# Matrix
dataframe <- as.matrix(dataframe[, c("Open", "High", "Low", "Close", "Volume")])

microsoft_ts <- ts(dataframe, 
               start = c(2015, 4),  
               frequency = 365)

# Subset data
microsoft_ts_trimmed <- ts(
  microsoft_ts[1:(1511 - 30), ],       
  start = start(microsoft_ts),         
  frequency = frequency(microsoft_ts)  
)

```

```{r}
plot(microsoft_ts_trimmed, main="")

```

```{r}
plot(microsoft_ts_trimmed[, "Close"], 
     main = "Closing price over time",
     xlab = "date",
     ylab = "Closing price")
```

# Step 2 

## a)

Exponetial smoothing använder man holtwinters() med $Gamma = False$ och
$beta = False$ kommer ge en enkel expoential smoothing!

```{r}
close_ts <- microsoft_ts_trimmed[, "Close"]

exp_smoother <- HoltWinters(close_ts,alpha =0.1, beta = FALSE, gamma = FALSE)

plot(exp_smoother, main = "Exponential Smoothing - Closing Price", ylab = "Closing Price", xlab = "Date")

legend("topleft", legend = c("Original", "Exponential Values"), col = c("black", "red"), lty = 1)


```

## b)

Skapa en funktion som hittar rolling_forecast

```{r}
rolling_forecast <- function(
    data,
    first_pred = time(data)[length(data) - 30],
    last_pred = time(data)[length(data)],
    steps_ahead = 1
) {
    end <- first_pred - 1/365
    preds <- list()
    i <- 1
  
    while (end < (last_pred - 0.01)) {
        train <- window(data, end = end)
        model <- HoltWinters(train)
        preds[[i]] <- predict(model, n.ahead = steps_ahead)
        end <- end + 1/365
        i <- i + 1
    }
  
    all_preds <- ts(
        unlist(preds),
        start = first_pred,
        frequency = frequency(data)
    )
  
    return(all_preds)
}
```

Predict på datan

```{r, message=FALSE, warning=FALSE}
microsoft_ts_rolling <- microsoft_ts[, 4]
forecast <- rolling_forecast(
    data=microsoft_ts_rolling,
    steps_ahead = 1
)
forecast_hS <- rolling_forecast(
    data = microsoft_ts_rolling,
    steps_ahead = 4
)
```

Plotting forecast

```{r}
plot(forecast)
plot(forecast_hS)
```

Räknar ut båda RMSE och MAD

```{r}
microsoft_ts_trimmed_last_30 <- ts(
  microsoft_ts[1481:1511, ],       
  start = end(microsoft_ts_trimmed),         
  frequency = frequency(microsoft_ts)  
)


calc_metrics <- function(actual, predicted) {
    rmse <- sqrt(mean((actual - predicted)^2, na.rm = TRUE))
    mad <- mean(abs(actual - predicted), na.rm = TRUE)
    c(RMSE = rmse, MAD = mad)
}


metrics0 <- calc_metrics(actual = microsoft_ts_trimmed_last_30[,4], predicted = forecast)
metrics0
metrics1 <- calc_metrics(actual = microsoft_ts_trimmed_last_30[,4], predicted = forecast_hS)
metrics1
```

OBS något gick fel använd 28 istället

## c) 

```{r}
alpha <- 0.05
z <- qnorm(1 - alpha / 2)

# plot
plot(microsoft_ts_trimmed_last_30[, 4], col = "black", lwd = 2, main = "h = 1",
     ylab = "price")
lines(forecast, col = "blue", lwd = 2)
polygon(c(time(forecast), rev(time(forecast))),
        c(forecast - z * sd(forecast), rev(forecast + z * sd(forecast))),
        col = rgb(0, 0, 1, 0.2), border = NA)

plot(microsoft_ts_trimmed_last_30[, 4], col = "black", lwd = 2, main = "h = S",
     ylab = "price")
lines(forecast_hS, col = "blue", lwd = 2)
polygon(c(time(forecast_hS), rev(time(forecast_hS))),
        c(forecast_hS - z * sd(forecast_hS), 
        rev(forecast_hS + z * sd(forecast_hS))),
        col = rgb(1, 0, 0, 0.2), border = NA)


```

## d) 

```{r}
set.seed(99)
N <- length(microsoft_ts_trimmed_last_30[, 4])
x0 <- microsoft_ts_trimmed_last_30[, 4][1]
mu <- mean(diff(microsoft_ts_trimmed_last_30[, 4]))
variance <- var(diff(microsoft_ts_trimmed_last_30[, 4]))

RW <- function(N, x0, mu, variance) {
  z <- cumsum(rnorm(n = N, mean = 0, sd = sqrt(variance)))
  t <- 1:N
  x <- x0 + t * mu + z
  return(x)
}

random_walk <- RW(N = N, x0 = x0, mu = mu, variance = variance)

random_walk_ts <- ts(random_walk, start = start(microsoft_ts_trimmed_last_30),
                     frequency = frequency(microsoft_ts_trimmed_last_30))

plot(random_walk_ts, type = "l", col = "blue", lwd = 2, 
     main = "Random Walk", 
     xlab = "Time", 
     ylab = "Price")

lines(microsoft_ts_trimmed_last_30[, 4], 
      col = "red", 
      lwd = 2, 
      lty = 2)

legend("topright", 
       legend = c("Random Walk", "Original Data"), 
       col = c("blue", "red"),
        lty = c(1, 2), 
       lwd = c(2, 2))

```

## Lets simulate a few random walks

```{r}
set.seed(99)
score <- c(RMSE = 0, MAD = 0)
best_model = c(RMSE = 0, MAD = 0)
best_rmse <- Inf

for (i in 1:1000){
  random_walk <- RW(N = N, x0 = x0, mu = mu, variance = variance)

  random_walk_ts <- ts(random_walk, start = start(microsoft_ts_trimmed_last_30),
                       frequency = frequency(microsoft_ts_trimmed_last_30))
  
  result = calc_metrics(actual = microsoft_ts_trimmed_last_30[,4], 
                        predicted = random_walk_ts)
  score = score + result
  if (result["RMSE"] < best_rmse){
    best_rmse = result["RMSE"]
    best_model = result
  }
 
}
score/1000
best_model
```
